// This package defines lemmas for sets commonly used in specifications.
package sets

// TODO Add proper attribution
// SO Not taken from outside sources
// S1 https://github.com/dafny-lang/libraries/blob/master/src/Collections/Sets/Sets.dfy
// S2 https://github.com/verus-lang/verus/blob/main/source/pervasive/set_lib.rs
// S3 https://why3.lri.fr/stdlib/set.html


// (How) Should we transform the axiomization of sets into lemmas?

// TODO Restructure, rename and properly document definitions at the end
// (in particular consistency in names of functions, arguments, variables)

// QUES How will set literals be interpreted if we turn of the axioms?

// TODO Figure out what the Gobra warnings are
// TODO Unicode comments?

// SO
// TODO Figure out how to import these from verify.gobra
type Unit struct{}

ghost
requires b
decreases
pure func Asserting(ghost b bool) Unit {
	return Unit{}
}

ghost
ensures false
decreases _
func TODO()

// SKIP S1: LemmaSubset<T>, quantified definition of subset

// SO
// Returns whether x is a proper subset of y.
ghost
decreases
pure func IsProperSubset(x, y set[int]) bool {
	return x subset y && x != y
}

// SO
// Returns a singleton set containing x.
ghost
decreases
pure func Singleton(x int) set[int] {
	return set[int] {x}
}

// TODO Figure out how to properly formalize empty (see comment about
// empty from S3 below)

// TODO Figure out how to properly formalize Singleton; probably requires
// similar considerations as empty

// S0
// Returns an empty set.
ghost
decreases
pure func Empty() set[int] {
	return set[int] {}
}

// S2
// Returns whether x is empty.
ghost
decreases
pure func IsEmpty(x set[int]) bool {
	return len(x) == 0
}

// S0/S1
// Returns an element from a non-empty set.
ghost
requires !IsEmpty(xs)
ensures x in xs
ensures len(xs) == 1 ==> xs == Singleton(x)
decreases
pure func choose(xs set[int]) (x int)

// TODO Get IsProperSubset case to verify
// S1
// If x is a subset of y, then the size of x is less than or equal to the size of y.
// If x is a strict subset of y, then the size of x is less than to the size of y.
// ghost
// decreases x, y
// ensures x subset y ==> len(x) <= len(y)
// ensures IsProperSubset(x, y) ==> len(x) < len(y)
// func SubsetSize(x, y set[int]) Unit {
	// if len(x) != 0 {
		// ghost e := choose(x)
		// SubsetSize(x setminus set[int] {e}, y setminus set[int] {e})
	// }
	// return Unit{}
// }

// S1
// If x is a subset of y and both have the same size, they are equal.
ghost
requires x subset y
requires len(x) == len(y)
ensures x == y
decreases
pure func SubsetEquality(x, y set[int]) Unit {
	return Asserting(len(y setminus x) == len(y) - len(x))
}

// S1
// A singleton set has a size of 1.
ghost
requires x == Singleton(e)
ensures len(x) == 1
decreases
pure func SingletonSize(x set[int], e int) Unit {
	return Unit{}
}


// TODO Prove this (Dafny Proof uses strict SubsetSize)
// S1
// Elements in a singleton set are equal to each other.
// ghost
// requires len(x) == 1
// requires a in x
// requires b in x
// ensures a == b
// pure func SingletonEquality(x set[int], a, b int) Unit {
// 	return Unit{}
// }

// SKIP S1: IsSingleton (quantified predicate)
// SKIP S1: LemmaIsSingleton (uses IsSingleton)
// NOTE S1: ExtractFromNonEmptySet and S1: ExtractFromSingleton are in choose

// SKIP S1: MapSize<> (no Injective() defined)
// SKIP S1: Map<> (no Injective() defined)
// SKIP S1: LemmaFilterSize<> (not sure whether ~>/passing functions exists in Gobra)
// SKIP S1: Filter (not sure whether ~>/passing functions exists in Gobra)

// S1
// The size of a union of two sets is greater than or equal to the size of
// either individual set.
ghost
ensures len(xs union ys) >= len(xs)
ensures len(xs union ys) >= len(ys)
decreases ys
pure func UnionSizeLower(xs, ys set[int]) Unit {
	return IsEmpty(ys) ? Unit{} :
		let y := choose(ys) in
		(let yr := Remove(ys, y) in
		(y in xs ?
			(let xr := Remove(xs, y) in
			(let _ := Asserting(xr union yr == Remove(xs union ys, y)) in UnionSizeLower(xr, yr))) :
			(let _ := Asserting(xs union yr == Remove(xs union ys, y)) in UnionSizeLower(xs, yr))))
}
// Proof using non-pure function (TODO delete if above is okay)
// func LemmaUnionSize(xs, ys set[int]) Unit {
// 	if len(ys) != 0 {
// 		ghost y := choose(ys)
// 		ghost yr := ys setminus Singleton(y)
// 		if y in xs {
// 			ghost xr := xs setminus Singleton(y)
// 			assert xr union yr == xs union ys setminus Singleton(y)
// 			LemmaUnionSize(xr, yr)
// 		} else {
// 			assert xs union yr == xs union ys setminus Singleton(y)
// 			LemmaUnionSize(xs, yr)
// 		}
// 	}
// }


// S1
// Construct a set with all integers in the range [a, b).
ghost
requires a <= b
ensures forall i int :: { i in s } (a <= i && i < b) == i in s
ensures len(s) == b - a
decreases b - a
pure func SetRange(a, b int) (s set[int]) {
	return a == b ? Empty() : Add(SetRange(a + 1, b), a)
}

// S1
// Construct a set with all integers in the range [0, n).
ghost
requires n >= 0
ensures forall i int :: {i in s} (0 <= i && i < n) == i in s
ensures len(s) == n
decreases
pure func SetRangeFromZero(n int) (s set[int]) {
	return SetRange(0, n)
}

// TODO S1: LemmaBoundedSetSize (Dafny proof requires LemmaSubsetSize +
// contains unclear forall in proof)

// SKIP S1: LemmaGreatestImplies{Minimal, Maximal}, LemmaMaximalEquivalentGreatest
// LemmaMinimalEquivalentLeast, LeammLeastIsUnique, LemmaGreatestIsUnique, LemmaMinimalIsUnique
// LemmaMaximalIsUnique, LemmaFindUniqueMinimal, LemmaFindUniqueMaximal
// since Orderings are not defined

// SKIP S2: is_full (don't have a notion of full)
// SKIP S2: map<B>, fold<E> (cannot pass functions)
// SKIP S2: to_seq() (not sure whether its fine to have forall + exists in ensures)
// SKIP S2: to_sorted_seq() (cannot pass function)
// SKIP S2: is_singleton() (including forall like that feels off)
// SKIP S2: find_unique_{mmaximal, minimal*}() (cannot pass function)

// TODO convert this into a pure function
// S2
// Converts a set into a multiset where each element from the set has
// multiplicity 1 and any other element has multiplicity 0.
ghost
ensures forall i int :: {i # ms} (i in s) ==> ((i # ms) == 1)
ensures forall i int :: {i # ms} (!(i in s)) ==> ((i # ms) == 0)
decreases s
func ToMultiset(s set[int]) (ms mset[int]) {
	if IsEmpty(s) {
		return mset[int] {}
	} else {
		ghost x := choose(s)
		return ((mset[int] {}) union (mset[int] {x})) union ToMultiset(Remove(s, x))
	}
}

// TODO Are we going to need lemmas of the form i # xmset > 0 ==> i in xmset?

// SKIP: S2: lemma_len0_is_empty(self) <- this one is confusing, since we defined IsEmpty before
// SKIP: S2: lemma_singleton_size + lemma_is_singleton (not sure whether we need 
// these, as singleton isn't a separate notion)
// SKIP: S2: lemma_len_filter, lemma_greatest_implies_maximal, lemma_least_implies_minimal,
// lemma_maximal_equivalent_greatest, lemma_minimal_equivalent_least, lemma_least_is_unique,
// lemma_greatest_is_unique, lemma_minimal_is_unique, lemma_maximal_is_unique (cannot pass functions/no ordering)

// S2
// The size of a union of two sets is less than or equal to the size of
// both individual sets combined.
ghost
ensures len(xs union ys) <= len(xs) + len(ys)
decreases
pure func UnionSizeUpper(xs, ys set[int]) Unit {
	return Unit{}
}

// SKIP: S2: lemma_len_union_ind (corresponds to UnionSizeLower from S1)

// S2
// The size of the intersection of xs and ys is less than or equal to the
// size of xs.
ghost
ensures len(xs intersection ys) <= len(xs)
decreases xs
pure func IntersectSizeUpper(xs, ys set[int]) Unit {
	return IsEmpty(xs) ? Unit{} :
		let x := choose(xs) in
		(let _ := Asserting((Remove(xs, x)) intersection ys == Remove((xs intersection ys), x)) in
		(IntersectSizeUpper(Remove(xs, x), ys)))

}
// Proof using non-pure function (TODO delete if above is okay)
// ghost
// ensures len(xs intersection ys) <= len(xs)
// decreases xs
// func IntersectSizeUpper(xs, ys set[int]) Unit {
// 	if !IsEmpty(xs) {
// 		ghost x := choose(xs)
// 		assert (xs setminus Singleton(x)) intersection ys == (xs intersection ys) setminus Singleton(x)
// 		return IntersectSizeUpper(xs setminus Singleton(x), ys)
// 	}
// }

// SKIP: S2 lemma_len_subset corresponds to SubsetSize from S1

// S2
// The size of the difference xs - ys is less than or equal to the size of xs. 
ghost
ensures len(xs setminus ys) <= len(xs)
decreases
pure func SetminusSizeUpper(xs, ys set[int]) Unit {
	return Unit{}
}

// SKIP: S2: set_int_range, lemma_int_range correspond to SetRange from S1
// SKIP: S2: lemma_subset_equality corresponds to SubsetEquality from S1

// SKIP: S2: lemma_map_size (cannot pass function)

// TODO Do we need lemmas to assert that union and intersect are commutative?

// S2
ghost
ensures (xs union ys) union ys == xs union ys
decreases
pure func UnionAgain1(xs, ys set[int]) Unit {
	return Unit{}
}

// S2
ghost
ensures (xs union ys) union xs == xs union ys
decreases
pure func UnionAgain2(xs, ys set[int]) Unit {
	return Unit{}
}

// S2
ghost
ensures (xs intersection ys) intersection ys == (xs intersection ys)
decreases
pure func IntersectAgain1(xs, ys set[int]) Unit {
	return Unit{}
}

// S2
ghost
ensures (xs intersection ys) intersection xs == (xs intersection ys)
decreases
pure func IntersectAgain2(xs, ys set[int]) Unit {
	return Unit{}
}

// S2
// If ys contains e, then the difference xs - ys does not contain e.
ghost
ensures e in ys ==> !(e in (xs setminus ys))
decreases
pure func SetDifference2(xs, ys set[int], e int) Unit {
	return Unit{}
}

// SKIP S2: lemma_set_disjoint (no notion of disjoint in Gobra)
// SKIP S2: lemma_set_empty_equivalency_len (unclear how it ties to the rest,
// since we already consider IsEmpty() and Choose())

// SKIP S2: lemma_set_disjoint_lens (no notion of disjoint in Gobra)

// S2 (proves slightly different version)
ghost
ensures len(xs union ys) == len(xs) + len(ys) - len(xs intersection ys)
decreases
pure func UnionSizeEq(xs, ys set[int]) Unit {
	return Unit{}
}

// S2
ghost
ensures len(xs setminus ys) == len(xs) - len(xs intersection ys)
ensures len(xs setminus ys) + len(ys setminus xs) + len(xs intersection ys) == len(xs union ys)
decreases
pure func SetminusSize(xs, ys set[int]) Unit {
	return Unit{}
}

// SKIP: S2: axiom_is_empty (seems to be more or less choose)
// SKIP: S2: check_argument_is_set<A> (seems to be specific to Verus)
// SKIP: S2: Macros (seems to be specific to Verus)

// SKIP S3: Potentially infinite sets (no support in Gobra)

// S3: Finite sets
// ***************
// SKIP S3: type fset 'a, meta "material_type_arg" type fset, 0
// (don't seem to apply to Gobra)

// SKIP S3: mem (built-in `in`)
// SKIP S3: (==) (built-in `==`)
// SKIP S3: extensionality (don't seem to apply to Gobra)
// SKIP S3: subset (seems to be quantified axiom)

// S3
// Definition of subset without quantifiers.
ghost
requires e in xs
requires xs subset ys
ensures e in ys
decreases
pure func Subset(xs, ys set[int], e int) Unit {
	return Unit{}
}

// S3
// Subset relation is reflexive.
ghost
ensures xs subset xs
decreases
pure func SubsetReflexive(xs set[int]) Unit {
	return Unit{}
}

// S3
// Subset relation is transitive.
ghost
requires xs subset ys
requires ys subset zs
ensures xs subset zs
decreases
pure func SubsetTransitive(xs, ys, zs set[int]) Unit {
	return Unit{}
}

// SKIP: S3 is_empty, empty, is_empty_empty, empty_is_empty
// unsure how to formalize the empty set: Is it defined as {}, a set of len 0,
// or as a set s such that forall e . e not in s?


// TODO Can we write functions like Add, Remove, etc. (and some above) as Go
// methods?
// S3 (add, add_def)
// Add an element x to the set xs.
ghost
// Need this post-condition to verify CardinalAdd
ensures (x in xs) ==> res == xs
decreases
pure func Add(xs set[int], x int) (res set[int]) {
	return xs union Singleton(x)
}
// QUES add_def has mem y (add x s) <-> (mem y s \/ y = x) as its definition
// We push the work to union; (how) do we need to formalize it?

// SKIP S3: singleton <- already define it as literal in Singleton (S0)
// SKIP S3: mem_singleton: contains quantifiers; unsure how to formalize singletons:
// as set of length one? forall x, y. y in Singleton(x) => x = y (S3)?
// forall x, y: x in Singleton(_) && y in Singleton(_) => x == y (S1, S2)?

// S3
// Remove the element x from the set xs.
// TODO Should we add something like ensures !(x in xs) ==> xs == Remove(xs, x)
// like we did for Add?
ghost
decreases
pure func Remove(xs set[int], x int) set[int] {
	return xs setminus Singleton(x)
}
// QUES remove_def has mem y (remove x s) <-> (mem y s /\ y <> x) as its definition
// We push the work to setminux; (how) do we need to formalize it?

// S3
// If x is in the set xs, removing and adding it back in does not change the set
ghost
requires x in xs
ensures Add(Remove(xs, x), x) == xs
decreases
pure func AddRemove(xs set[int], x int) Unit {
	return Unit{}
}

// S3
// If we remove x from the set xs, it doesn't matter whether we have added x
// to it before.
ghost
ensures Remove(Add(xs, x), x) == Remove(xs, x)
decreases
pure func RemoveAdd(xs set[int], x int) Unit {
	return Unit{}
}

// S3
ghost
ensures Remove(xs, x) subset xs
decreases
pure func SubsetRemove(xs set[int], x int) Unit {
	return Unit{}
}

// SKIP S3: union (union is already a "symbol" in Gobra)
// SKIP S3 union_def (quantified defintion of union)
// TODO Should we merge SubsetUnion1 and SubsetUnion2?
// S3
ghost
ensures xs subset (xs union ys)
decreases
pure func SubsetUnion1(xs, ys set[int]) Unit {
	return Unit{}
}

// S3
ghost
ensures ys subset (xs union ys)
decreases
pure func SubsetUnion2(xs, ys set[int]) Unit {
	return Unit{}
}

// SKIP S3: inter (intersection is already a "symbol" in Gobra)
// SKIP S3: inter_def (quantified definition of intersection)

// S3
ghost
ensures (xs intersection ys) subset xs
decreases
pure func SubsetIntersection1(xs, ys set[int]) Unit {
	return Unit{}
}

// S3
ghost
ensures (xs intersection ys) subset ys
decreases
pure func SubsetIntersection2(xs, ys set[int]) Unit {
	return Unit{}
}


// SKIP S3: diff (setminus is already a "symbol" in Gobra)
// SKIP S3: diff_def (quantified definition of setminus)

// S3
ghost
ensures (xs setminus ys) subset xs 
decreases
pure func SubsetSetminus(xs, ys set[int]) Unit {
	return Unit{}
}

// SKIP S3: pick, pick_def (corresponds to Choose)
// SKIP S3: disjoint, disjoint_inter_empty, disjoint_diff_eq,
// disjoint_diff_s2: definition of disjoint requires a quantifier
// TODO Notion of disjoint seems useful; (how) should we implement it?

// SKIP S3 filter, filter_def, subset_filter, map, map_def, mem_map (cannot pass functions)

// S3
ghost
ensures len(xs) >= 0
decreases
pure func CardinalNonneg(xs set[int]) Unit {
	return Unit{}
}

// S3 SKIP: cardinal_empty: What does it mean for a set to be empty? (see above)

// S3
ghost
ensures (x in xs) ==> (len(Add(xs, x)) == len(xs))
ensures !(x in xs) ==> (len(Add(xs, x)) == len(xs) + 1)
decreases
func CardinalAdd(xs set[int], x int) Unit {
	return Unit{}
}

// S3
ghost
ensures (x in xs) ==> (len(Remove(xs, x)) == len(xs) - 1)
ensures !(x in xs) ==> (len(Remove(xs, x)) == len(xs))
decreases
func CardinalRemove(xs set[int], x int) Unit {
	return Unit{}
}

// SKIP S3 cardinal_subset => corresponds to S1 SubsetSize
// SKIP S3 subset_eq => corresponds to S1 SubsetEquality

// S3
// If xs is a Singleton, and x is in xs, then choose(xs) will always return x.
ghost
requires len(xs) == 1
ensures x in xs ==> choose(xs) == x
decreases
pure func Cardinal1(xs set[int], x int) Unit {
	return Unit{}
}

// SKIP S3 cardinal_union => corresponds to S2 UnionSizeEq
// SKIP S3 cardinal_inter_disjoint (no notion of disjoint in gobra)
// SKIP S3 cardinal_diff => included in S2 SetminusSize
// SKIP S3 cardinal_filter, cardinal_map (cannot pass functions)

// SKIP S3: Induction principle on finite sets

// SKIP S3: min_elt{,_def}, max_elt{,_def} mention forall x . x in xs in
// their post-condition; not sure whether we want such a function

// SKIP S3: interval, interval_def, cardinal_interval => correspond to SetRange

// SKIP Sum of a function over a finite set => cannot pass functions

// S3 The sections in "Finite Monomorphic sets" suggest to move cardinality properties as a
// postcondition to functions that "generate" it
// Empty() would return an empty list, but also ensure that its cardinality is 0
// Add(xs, x) would return a set where x has been added to xs, but also ensure that
// the cardinality stays the same if x was already in xs, or increases if it wasnt
// A similar consideration is made for Singleton(x) and Remove(xs, x)
// TODO Consider whether we want to merge functions like this
